# Конвертация VCL-приложения в Lazarus

# Оглавление

Введение [...](#intro)

Альтернативы Lazarus [...](#other-ways)

Установка Lazarus [...](#laz-install)

    Настройка IDE Lazarus [...](#laz-config)

    Установка компонентов [...](#laz-components-install)

    Компоненты для работы с СУБД Firebird [...](#laz-components-firebird)

        Компоненты для работы с другими базами данных [...](#laz-components-other-db)

        Компоненты для работы с in-memory наборами данных [...](#laz-components-mds)

        Компоненты для оторажения набора данных (DBGrid) [...](#laz-components-dbgrid)

        Компоненты SpinEdit [...](#laz-components-spinedit)

        Компоненты для работы с JSON [...](#laz-components-json)

        Компоненты для работы с XML [...](#laz-components-xml)

        Компоненты для отображения HTML-страниц [...](#laz-components-html)

        Сетевые компоненты Indy10 [...](#laz-components-indy)

        Компоненты для работы с COM-портами [...](#laz-components-serial)

        Компоненты для работы с графикой [...](#laz-components-graphics)

        Компоненты для построения графиков [...](#laz-components-chart)

        Компонент VirtualTreeView (VTV) [...](#laz-components-vtv)

        Компоненты для хранения PNG-иконок [...](#laz-components-png)

Подготовка проекта к портированию [...](#laz-prepare-porting-start)

    Преобразование кодировки файлов с исходными кодами в UTF-8 [...](#laz-prepare-porting-codepage)

    Портировать на Lazarus все независимые модули. Убедиться в том, что они работают как на Windows, так и в Linux [...](#laz-prepare-porting-base-units)

    Отделение кода бизнес-логики от графического интерфейса [...](#laz-prepare-porting-split-code)

    Избавиться от взаимных (циклических) зависимостей между модулями [...](#laz-prepare-porting-unit-ref)

    Проверить в Lazarus работоспособность сторонних библиотек и компонентов [...](#laz-prepare-porting-check-components)

    Разработать модуль (либо несколько модулей) совместимости типов [...](#laz-prepare-porting-unit-compat-types)

    Разработать модуль (либо модули) с реализацей отсутствующих для Linux функций [...](#laz-prepare-porting-unit-compat-funcs)

    Исправить код преобразования типов, не учитывающий 64-битный код [...](#laz-prepare-porting-fix-64)

    Скорректировать объявления THandle [...](#laz-prepare-porting-fix-handle)

    Подготовьте модули DLL-библиотек к тому, что они могут быть включены в исполняемый файл [...](#laz-prepare-porting-prepare-dll)

    Произвести замену некоторых компонентов [...](#laz-prepare-porting-replace-components)

    По возможности избавиться от неиспользуемых компонентов, которые недоступны для Лазаруса [...](#laz-prepare-porting-remove-old-components)

    Избавиться от обработчика события OnDrawDataCell у компонента TDBGrid [...](#laz-prepare-porting-fix-event-drawdatacell)

    Исправить кодировку текста в базе данных [...](#laz-prepare-porting-fix-db-encode)

Конвертация форм dfm -> lfm [...](#laz-convert-forms)    

    Трудности конвертации форм в Лазарусе [...](#laz-convert-forms-problems)

    Разработка собственного инструмента конвертации форм [...](#laz-convert-forms-app)

    Привязка компонентов на форме [...](#laz-convert-forms-anchor-editor)

    Совместное редактирование форм в Delphi и Lazarus [...](#laz-convert-forms-joint-editing)

    Использование директив условной компиляции для корректировки объявлений используемых компонентов [...](#laz-convert-forms-directives)

Подключение стороннего менеджера памяти [...](#laz-mem-manager)

Подключение общего менеджера памяти в DLL-библиотеку [...](#laz-mem-manager-dll)

    Действия по установке общего менеджера памяти в библиотеке [...](#laz-mem-manager-dll-steps)

    Корректная выгрузка библиотеки с помощью FreeLibrary [...](#laz-mem-manager-freelibrary)

Обработка исключений, возникающих в DLL/SO-библиотеке [...](#laz-dll-exceptions)

Особенности обработки строк UTF-8 в Lazarus [...](#laz-strings)


## Введение <a name="intro"></a>

Я работаю программистом в [организации](https://automatikaplus.ru), одним из направлении деятельности которой является разработка решений для автоматизации АЗС и учёта ГСМ. Являюсь разработчиком нескольких программ, одной из которых является широко известное в узких кругах [программное обеспечение](https://automatikaplus.ru/default.aspx?id=kmazs). 
На 2024г данное ПО используют около 1500 организаций в России. Многие крупные компании используют наши контроллеры, а для взаимодействия с ними - наше ПО.

Разработка ведётся с использованием старой доброй Delphi 2007. В настоящее время данная версия Delphi считается безнадёжно устаревшей, однако переход на более новые версии требовал бы значительных (на фоне стоимости нашего ПО) финансовых затрат (по хорошему, каждый год требовалось бы продлевать подписку). Но самое главное - отсутствовали веские причины, благодаря которым можно было бы обосновать покупку новых версий Delphi. Основные современные технологии нам доступны (XML, SOAP, JSON, HTTP/HTTPS, REST, WEB-сервера, UniGui, JCL, JVCL, Indy10 и многое другое). Наше ПО используют в основном только в России, у всех пользователей русскоязычная ОС Windows, поэтому с проблемами отображения русскоязычного интерфейса мы не сталкиваемся.

Задумываться о поддержке Linux для данного проекта мы начали примерно 10 лет назад - уже тогда были потенциальные заказчики из госсектора, использующие ОС на базе Linux. Что я подразумеваю под словом "задумываться"? Это означает в первую очередь анализ компонентов и библиотек, используемых в проекте. Например, никто не мешал и 10 лет назад включить в проект компоненты DevExpress, однако мы воздержались от этого, посколько данные компоненты недоступны для Lazarus (именно Lazarus изначально рассматривался как инструмент для реализации поддержки Linux). Другой пример: мы начали использовать компоненты HTMLViewer только после того, как убедились в их доступности для Lazarus.

Учитывая тенденцию постепенного перехода госсектора на отечественные дистрибутивы Linux, руководством было принято решение реализовать поддержку Linux с помощью среды разработки Lazarus. К этому моменту была уверенность в осуществимости данной задумки, причем я предполагал, что вся работа займет не более трех месяцев. Проект не слишком большой, миллиона строк кода в нём ещё нет: порядка 100 форм (dfm и pas - файли) и около 100 модулей чистой бизнес-логики. Из сторонних компонентов в проекте только RxLib, Fundamentals-5, Indy10, VirtualTreeView, Hints, PNGImage, PNGComponents, SuperObject, Graphics32, SynPDF, SynEdit, TNTUnicode, HtmlViewer, DecimalRounding, AsyncPro.

На практике времени ушло на поддержку Linux значительно больше, чем три месяца. В ходе выполнения работы пришлось столкнуться к громадным количеством проблем, которых я не ожидал. И это несмотря на то, что я читал известную [статью-повесть](https://habr.com/ru/articles/534466/) Константина Тимофеева о портировании сложного модульного ПО под ОС Linux.

На 2024г мы не можем знать, насколько популярным окажется версия нашего ПО под Linux. Мы не можем быстро отказаться от Delphi, поэтому скорее всего в ближайшие годы основная разработка по прежнему будет выполняться в Delphi, а Lazarus будет использоваться - для сборки проекта под Linux.

## Альтернативы Lazarus <a name="other-ways"></a>

В данной статье я не рекламирую Lazarus, не говорю, что это лучший выбор для разработчика. Однако, если у вас есть достаточно крупный живой проект, который нужно постоянно дорабатывать, мысли о переписывании на другой язык программирования долго в голове не живут, это была бы нереальная для обычного программиста задача.

Я знаю только три реальные альтернативы:
1. Delphi + Wine (самый быстрый вариант, отличное решение, если у вас совсем нет времени на портирование, однако минусов в таком подходе вы в дальнейшем обнаружите предостаточно и, вероятно, будете жалеть о том, что сэкономили время и не сделали полноценное решение под Linux);
2. Delphi + UniGui - на мой взгляд - прекрасное решение. Оно потребует скорее всего больше времени, чем портирование на Lazarus, однако в результате у вас будет приложение с шикарным современным GUI (бонусом - собственное облачное решение), оно будет кроссплатформенным (Delphi сможет его компилировать и под Windows и под Linux), вам не придётся заморачиваться с графическими оболочками в Linux и не потребуется заново разрабатывать модули с бизнес-логикой. Вероятно я буду сожалеть, что не пошёл по этому пути (зато сэкономил пару месяцев...);
3. Delphi + замена VCL на FireMonkey - самое сложное решение. Идеология FMX очень сильно отличается от VCL. По сути, вам придётся заново разрабатывать каждую форму. Ситуация будет осложнятся отсутствием (из коробки) компонентов, аналогичных TDBGrid. Знатоки FMX умеют выкручиваться, однако начинающий потратит на получение нужных знаний не один месяц. Кроме того, в FMX отсутствует (из коробки) огромное количество визуальных компонентов, доступных для VCL. Данную проблему частично можно решить, приобретя набор компонентов от компании [TMS Software](https://www.tmssoftware.com).

Также в качестве альтернативы Лазарусу следует упомянуть среду разработки CodeTyphon (в качестве основы для CodeTyphon используются FPC и Lazarus). Она отличается от Лазаруса тем, что в ней по умолчанию установлено громадное количество различных компонентов (несколько тысяч). Для меня главный минус заключается в том, что пересборка IDE CodeTyphon (например, при установке нового компонента), занимает огромное количество времени (несколько десятков минут), в том время, как пересборка Лазаруса обычно укладывается в одну минуту. Кроме того, в доработке IDE Lazarus и компилятора FPC может участвовать "любой" разработчик (с огромным опытом работы и доверием со стороны других разработчиков), чего я не могу сказать про среду CodeTyphon. В любом случае, никто вам не мешает установить среду CodeTyphon для того, чтобы знать, какие компоненты доступны для FPC / Lazarus. Устанавливать CodeTyphon лучше сразу на Linux, поскольку современные файловые системы в Linux работают намного быстрее по сравнению с NTFS в ОС Windows. Для установки CodeTyphon объем ОЗУ должен быть не менее 8 ГБ.

## Установка Lazarus <a name="laz-install"></a>

Необходимо установить 64-битный Lazarus в ОС Windows и Linux. Мы использовали AstraLinux, Lazarus в нём работает, поэтому я могу рекомендовать данный российский дистрибутив Linux. Любой разработчик может скачать виртуальную машину с AstraLinux с официального сайта. Очень важно в параметрах гостевой ОС указать объём ОЗУ не менее 6 ГБ, иначе могут возникнуть трудности в пересборке Lazarus и FPC с помощью средства fpcupdeluxe.

Для установки Lazarus следует использовать дополнительную программу [fpcupdeluxe](https://github.com/LongDirtyAnimAlf/fpcupdeluxe) (доступны версии для ОС Windows и различных дистрибутивов ОС Linux). Автор регулярно её обновляет, следит за её актуальным состоянием.
После запуска программы fpcupdeluxe необходимо выбрать каталог для установки Lazarus и выбрать необходимую ветку с исходниками Lazarus и FPC. Учтите, что в ветках trunk (и для Lazarus и для FPC) находятся самые свежие коммиты, которые позволят собрать самую актуальную версию среды разработки и компилятора. Однако далеко не всегда удаётся собрать их из веток trunk (очень часто сборка ломается после неудачных коммитов). Если вы знаете идентификатор удачного коммита, то можете указать его в параметрах fpcupdeluxe. 

Ветки stable считаются стабильными, однако, на мой взгляд, нет большого смысла их использовать из fpcupdeluxe. Тем более мало кто знает, что вкладывает автор программы fpcupdeluxe в понятие "stable". В исходных кодах программы fpcupdeluxe уточняется, из какой ветки будут загружены исходники FPC/Lazarus, если выбрана ветка stable. Я считаю, что лучше не гадать, а выбрать вручную конкретную ветку.

Для компилятора FPC мы для своего проекта решили использовать ветку  fixes-3.2. Ветки "fixes" являются достаточно стабильными и в них периодически делают исправления ошибок, не увлекаясь добавлением новых языковых возможностей. При этом ветка fixes-3.2 периодически заимствует из ветси trunk новые RTL-модули, которые доказали свою надёжность). Мы многократно пытались экспериментировать с веткой trunk для FPC, однако так и не смогли получить приёмлемый вариант. Мы сталкивались со следующими проблемами:
а) не проходила компиляция/сборка FPC либо среды разработки;
б) программа успешно компилировалась, но при запуске возникали ошибки из-за некорректной генерации машинного кода;
в) используемые в нашем проекте компоненты не компилировались;
г) используемые компоненты работали некорректно.

Дело в том, что многие разработчики компонентов для Lazarus ориентируются в первую очередь на штатную версию компилятора FPC, а с текущими версиями (trunk) предпочитают не связываться.
Следует отметить, что в 2024г происходит аномально активная деятельность в части развития компилятора FPC. Видимо, разработчики стремятся поддержать все текущие языковые возможности Delphi для того, чтобы максимально упростить процесс портирования больших проектов на Linux, поэтому ветка trunk сейчас весьма нестабильная. Но я уверен, что следствием этих работ будет появление стабильной версии компилятора, которым все разработчики смогут уверенно пользоваться.

В программе fpcupdeluxe есть ссылка на HTML-страницу с [отчётом](http://fpcuplogger.batterybutcher.com/root/getinfohtml?ShowErrors=yes) по результатам установки Lazarus/FPC из различных веток. К сожалению, на этой странице отображается информация только по установкам, выполненным в ОС Windows, также отсутствуют конкретные номера коммитов. 

Если вы хотите точно определить, какой ветке на gitlab соответствует ветка "fixes", откройте файл "fpcup.ini", который создаётся автоматически при запуске fpcupdeluxe. В нём найдите секции "ALIASfpcBRANCH" и "ALIASlazBRANCH" и изучите их содержимое.

Среду разработки Lazarus я рекомендую ставить из ветки trunk. В 2024г добавляется очень много возможностей, связанных с поддержкой Linux, в том числе очень активно улучшается отладчик под Linux (этим вопросом занимаются профессионалы высочайшего уровня). Обратите внимание на то, что отладчик находится в составе Lazarus, а не FPC. Очень многие разработчики устанавливают среду разработки Lazarus из ветки trunk. Проблемы с Lazarus из этой ветки случаются, но гораздо реже, чем проблемы с FPC из ветки trunk.

Программа fpcupdeluxe содержит огромное количество возможностей. Наиболее ценные, на мой взгляд:
1) возможность собрать FPC и Lazarus в режиме отладки (нажать "Setup+" и поставить флаг "Debug" напротив "FPC Options" и напротив "Laz. Options") - рекомендую обязательно воспользоваться данной возможностью;
2) возможность устанавливать дополнительные пакеты/компоненты, включенные в состав Lazarus (находятся в папке "lazarus/components");
3) возможность устанавливать дополнительные пакеты/компоненты из внешних ресурсов;
4) возможность полностью пересобрать FPC/Lazarus без повторной загрузки исходников из gitlab (флаг "FPC/Laz rebuild only");
5) возможность указать конкретный идентификатор коммита для выбранных веток FPC и Lazarus. Пример идентификатора коммита: "a7fb4d5593". Это особенно полезно для ветки trunk. Например, вам удалось дома скачать удачный коммит FPC, а зная идентификатор коммита, вы сможете скачать тот же самый коммит на работе либо на другом своём компьютере. Идентификаторы коммитов для FPC и Lazarus вы можете найти в файле "lazarus/fpcuprevisions.log".

### Настройка IDE Lazarus <a name="laz-config"></a>

По умолчанию среда разработки запускается в многооконном режиме (одновременно открывается множество окон, каждое из которых можно переместить, свернуть либо закрыть). На мой взгляд, более удобным режимом является однооконный режим (все инструменты собраны в одном окне, представлены в виде отделённых друг от друга панелей). Для этого необходимо установить следующие пакеты: AnchorDocking, AnchorDockingDsgn, DockedFormEditor.

Для работы вам понадобится инструмент AnchorEditor. Это менеджер привязки компонентов друг к другу. Для его открытия щелкните меню "View / Anchor Editor". Рекомендую сразу же сделать его встроенным в главное окно Lazarus (так намного удобнее работать с данным инструментом, особенно если вы работаете на 27-дюймовом мониторе). Для этого наведите мышкой на полоску с мелкими точками (в окне "Anchors of FormXXX"), зажмите левую кнопку мыши и переместите окно в удобное место, например, в правой части главного окна среды разработки. Отстыковать окно можно точно таким же способом (нажать на полоске с мелкими точками). 

Также рекомендую установить пакет OnlinePackageManager. После его установки будет доступно средство для загрузки и автоматической установки различных сторонних пакетов/компонентов. Всего будет доступно около 300 пакетов/компонентов. Сразу хочу предупредить, что у данного средства есть минусы:
а) содержит далеко не все пакеты, доступные для Lazarus;
б) скачивание пакетов выполняет с собственного сервера. Для многих пакетов на его сервере находятся устаревшие версии. Я столкнулся с такой проблемой при попытке установить пакет [rxnew](https://sourceforge.net/p/lazarus-ccr/svn/HEAD/tree/components/rx/trunk/) от Алексея Лагунова. Данный пакет содержит набор популярных для Lazarus компонентов, среди который необходимо в первую очередь отметить TRxMemoryData и TRxDBGrid. Выяснилось, что на сервере OnlinePackageManager пакет "rxnew" устаревший, причем он не компилируется (требуется вручную внести некоторые исправления в его исходные коды). Оказалось, что для "rxnew" наиболее правильным способом установки является скачивание актуальной версии из https://sourceforge.net/p/lazarus-ccr/svn/HEAD/tree/components/ и дальнейшая установка через меню "Package / Open Package File (.lpk)". Вывод: перед тем, как выполнить установку того или иного компонента с помощью OnlinePackageManager, проверьте, нет ли более свежей версии на sourceforge.net.

В другой стороны, на сервере OnlinePackageManager для некоторых компонентов находится работоспособная версия, а их актуальная версия (на сайте разработчика компонентов либо на github) под Lazarus не компилируется (пример: компонент HTMLViewer, который автор, по всей видимости, тестирует в основном только под Delphi).

Рекомендую сразу включить настройку для автоматической подстановки пробелов вокруг оператора "присвоить" (:=). Для этого следует щелкнуть меню Tools \ Options, выбрать раздел "Codetools" \ Space и включить флаг "Symbol" в поле "Insert space in front of" и "Insert space after".

### Установка компонентов <a name="laz-components-install"></a>

#### Компоненты для работы с СУБД Firebird <a name="laz-components-firebird"></a>

Наше ПО работает с СУБД Firebird с помощью компонентов IBExpress (IBX). Существуют версии компонентов IBX, доступные для Lazarus и работают они как в ОС Windows, так и в Linux. Мы используем версию компонентов IBX от компании [mwasoftware](https://svn.mwasoftware.co.uk/public/ibx/trunk/). 

Кроме компонентов IBX, в проекте используется моя библиотека [ibxFBUtils](https://github.com/loginov-dmitry/ibxfbutils), которая значительно упрощает работу с базами данных Firebird. Данная библиотека поддерживает и Delphi и Lazarus (для ОС Windows и Linux). Библиотеке ibxFBUtils посвящена отдельная [статья](http://loginovprojects.ru/index.php?page=ibxfbutils).

Следует отметить важную особенность компонентов IBX от mwasoftware: вы не можете использовать ключевые слова в именах параметров. Например, следующий запрос будет ошибочным:
```sql
SELECT * FROM MYTABLE WHERE SALETIME BETWEEN :from to :to
```
вместо ":from" и ":to" следует указать имена, которые не относятся к ключевым словам, например ":begTime" и ":endTime".

#### Компоненты для работы с другими базами данных <a name="laz-components-other-db"></a>

Нам повезло - в нашем ПО не используются компоненты для других баз данных, а для работы с базами Firebird мы используем именно IBExpress. Если бы в нашем проекте применялись компоненты FIBPlus либо FireDAC, то пришлось бы приложить дополнительные усилия для написания кроссплатформенного кода. Так или иначе, задача решаемая, тем более все компоненты для работы с наборами данных являются наследниками от класса TDataSet.

В нашем проекте имеется функционал по экспорту данных в DBF-файлы и по импорту из DBF-файлов. Для Delphi2007 используется мой модуль [MemDBFTable](https://github.com/loginov-dmitry/loginovprojects/tree/master/memdbftable). Для Lazarus можно использовать компонент TDbf, который поставляется в комплекте с компилятором FPC. Обратите внимание на то, что компонент TDbf в Линуксе напрочь не понимает русские кодировки WIN1251 и CP866. Для того, чтобы решить эту проблему, достаточно сделать наследника от TDbf таким образом:

```pascal
  TDbf = class(dbf.TDbf)
  protected
    function GetCanModify: Boolean; override;
  end;
  
  ....... 

  function TDbf.GetCanModify: Boolean;
  begin
    if ReadOnly or (csDesigning in ComponentState) then
      Result := false
    else
      Result := True {FTranslationMode > tmNoneAvailable};
  end;  
```

Компонент TDbf сам не умеет выполнять перекодировки UTF - CP866, поэтому мы делаем перекодировку самостоятельно в момент присвоения текстового значения в TField с помощью функции ConvertEncodingFromUTF8 из модуля LConvEncoding.

Компоненты для работы с DBF мы используем только в момент экспорта либо импорта данных. Если мы хотим выполнить экспорт некоторого набора данных в DBF, то предварительно запрашиваем данные из базы данных (например с помощью компонента TIBDataSet) либо заполняем вручную in-memory набор данных (например, TRxMemoryData), и только потом задействуем компоненты для работы с DBF для непосредственного сохранения в DBF-файл. Я не считаю идеальной идеей вообще использовать сторонние компоненты для работы с DBF. Этот формат прост как пять копеек. Лучше реализовать собственные функции для сохранения любого набора данных TDataSet в DBF-файл и для загрузки из DBF-файла в заданный компонент TDataSet.

#### Компоненты для работы с in-memory наборами данных <a name="laz-components-mds"></a>

В проекте очень активно используются наборы данных "в памяти" - TRxMemoryData из библиотеки RxLib. Одной из причин их использования является улучшение работоспособности ПО при плохом качестве сетевого подключения к СУБД Firebird. К счастью, данный компонент доступен для Лазаруса в пакете rxnew от Алексея Лагунова. Версия от Алексея намного функциональнее по сравнению со старой RxLib, её следует сравнивать с компонентом TJvMemoryData из состава компонентов Jedi. В ней реализована мощная поддержка фильтрации (поддерживается свойство "Filter"), причём можно указывать сколь угодно сложное выражение для фильтрации. Также поддерживается сортировка по одному или нескольким полям.

Пакет rxnew можно установить вручную либо с помощью fpcupdeluxe.
 
#### Компоненты для оторажения набора данных (DBGrid) <a name="laz-components-dbgrid"></a>

В составе пакета rxnew присутствует мощный компонент для отображения набора данных: TRxDBGrid. По сравнению со стандартным TDBGrid, в TRxDBGrid намного больше функционала. Вот некоторые его возможности:
1) многоуровневые заголовки: если один столбец назвать "Товары | Наименование", а второй "Товары | Цена", то будет автоматически создана дополнительная строка заголовка "Товары", объединяющая столбцы "Наименование" и "Цена" (в том, случае, если эти столбцы расположены рядом);
2) встроенная сортировка;
3) встроенная фильтрация;
4) возможность отобразить строку "Итоги";
5) возможность выгрузки таблицы в PDF-файл (демонстрируется возможность выгрузить в PDF-файл любой информации, как текста, так и графики - векторной и растровой);
6) возможность выгрузки таблицы в файл формата MS Excel и LibreOffice Calc.
Возможности данного компонента демонстрируются в папке rx\trunk\demos\rxdbgrid.
Компонент TRxDBGrid внешне выглядит очень красиво, особенно при использовании библиотеки виджетов QT.

#### Компоненты SpinEdit <a name="laz-components-spinedit"></a>

В нашем проекте используются компоненты TRxSpinEdit и TJvSpinEdit. Эти компоненты (особенно TJvSpinEdit) визуально смотрятся интереснее по сравнению со стандартным TSpinEdit благодаря более крупным кнопкам "Вверх", "Вниз", разделённым наклонной линией. К счатью, в rxnew имеются такие компоненты и они работают прекрасно как в Windows, так и в Линукс.

#### Компоненты для работы с JSON <a name="laz-components-json"></a>

В нашем проекте для работы с JSON мы используем компоненты SuperObject. Связано это с тем, что мы используем Delphi2007, для которой отсутствует большой выбор компонентов для JSON (имеются ещё компоненты от fundametals-5 и McJSON). Разумеется, среди прочих аналогов самыми удобными являются SuperObject, однако это не самый хороший выбор, если вы просто создаёте JSON-файл без необходимости его парсинга. Для Lazarus удалось найти работоспособную версию компонента SuperObject по [ссылке](https://github.com/Makhaon/superobject) (номер коммита: be7911a17f0a5f65da2c02014ac6d8a32f8bcc8b).

#### Компоненты для работы с XML <a name="laz-components-xml"></a>

К сожалению стандартные компоненты для работы с XML в Lazarus и в Delphi сильно отличаются. В Delphi используются интерфейсы IXMLDocument, IXMLNode, а в Лазарусе TXMLDocument, TDOMNode. Нам пришлось делать дополнительный класс TXMLUtils, в котором учитываются различия в реализации. Код в нашем проекте теперь не привязан к конкретной реализации, а все вызовы осуществляет через класс TXMLUtils.

Наверняка существуют сторонние библиотеки для работы с XML, которые реализованы одинаково и для Delphi и для Lazarus.

#### Компоненты для отображения HTML-страниц <a name="laz-components-html"></a>

Некоторая информация в нашем проекте представлена в виде HTML-страниц. Для отображения HTML-страниц мы используем компоненты THtmlViewer. В помощью OnlinePackageManager можно легко установить эти компоненты для Lazarus (название пакета: FrameViewer09). Программа fpcupdeluxe также позволяет установить эти компоненты, но в этом случае они не компилируются либо не работают (видимо, автор компонентов редко проверяет их работоспособность в Lazarus).

Кроме того, имеются коммерческие компоненты [DelphiHTMLComponents](https://delphihtmlcomponents.com/) от гениального программиста Александра Свириденкова, которые доступны как для Delphi, так и для Lazarus. Они обеспечивают практически полную поддержку современных стандартов HTML и CSS, визуальное совпадение с браузерами, а по скорости отрисовки превосходят большинство современных браузеров.

#### Сетевые компоненты Indy10 <a name="laz-components-indy"></a>

В нашем ПО для работы с сетью используются компоненты из библиотеки Indy10 (TIdTCPClient, TIdTCPServer, TIdHTTPClient, TIdHTTPServer, TIdSMTPClient). Все эти компоненты работают в Lazarus. Установить библиотеку Indy10 удалось с помощью OnlinePackageManager.

Также в нашем ПО используются компоненты Overbyte ICS. Эти компоненты не являются кроссплатформенными. Для некоторых задач мы заменили компоненты ICS на Indy10, но в некоторых случаях в проекте теперь две реализации: одна на Overbyte ICS (для Windows) и другая на Indy10 (для Linux).

#### Компоненты для работы с COM-портами <a name="laz-components-serial"></a>

В нашем проекте используется собственная обёртка над WinAPI для работы с COM-портами. Для Лазаруса удалось найти пакет компонентов LazSerial, который ставится с помощью OnlinePackageManager. Обратите внимание на то, что в этом пакете имеется компонент TLazSerial, который мы не рекомендуем использовать в своих проектах (мало того, что модуль LazSerial.pas зависит от некоторых LCL-модулей, что мешает собирать консольные приложения и службы без GUI, но в этой реализации присутствуют ошибки). Весь необходимый функционал присутствует в модуле LazSynaSer.pas (класс TBlockSerial). Мы реализовали собственный компонент-обёртку над классом TBlockSerial и добились совместимости с имеющийся обёрткой над WinAPI.

#### Компоненты для работы с графикой <a name="laz-components-graphics"></a>

В Лазарусе практически полностью реализовано API для работы с графикой GDI. Причем, если для Windows используется API из состава Windows, то для Linux всё это API приходится эмулировать. Необходимость эмуляции WinAPI для графики GDI - это одна из причин огромного размера исполняемых файлов в Линуксе. Думаю, что это прибавляет около 10 МБ к размеру файла.
Таким образом, если для отрисовки на канве вы не используете сторонние библиотеки, то скорее всего ваш код под Линукс скомпилируется без проблем и отрисовка будет работать.

В нашем ПО используется дополнительная графическая библиотека Graphics32. Мы используем её функционал при необходимости отрисовать элементы с красивым сглаживанием, а также для поиска областей пересечений между сложными многоугольниками. Библиотеку Graphics32 можно установить с помощью OnlinePackageManager либо fpcupdeluxe, однако у нас заработала только версия, установленная через OnlinePackageManager (это более полноценная версия от PilotLogic).

#### Компоненты для построения графиков <a name="laz-components-chart"></a>

Для Лазаруса, как и для Delphi, реализован компонент TChart, на котором можно расположить одну или несколько "серий" для визуализации массивов данных в различных режимах отображения (линейный график, столбиковая диаграмма, круговая диаграмма и т.п.). И там и там компоненты имеют громадное количество возможностей, позволяют реализовать абсолютно любую задумку, но имеют в своих деталях огромное количество отличий (многие свойства и методы названы по-разному, многие вещи приходится делать по-разному). В составе Лазаруса имеются демо-проекты, демонстрирующие практически все возможности компонента TChart. Ознакомление с возможностями TChart займёт несколько дней. К сожалению, многие вещи в демо-проектах раскрыты недостаточно подробно, а в имеющейся документации описана лишь малая часть всех возможностей.

#### Компонент VirtualTreeView (VTV) <a name="laz-components-vtv"></a>

В составе Лазаруса уже имеется компонент TVirtualStringTree. Ему слегка изменили имя класса (TVirtualStringTree -> TLazVirtualStringTree), а также изменили наименование модуля (VirtualTrees -> laz.VirtualTrees), но компонент остался тем же самым. Данный компонент позволяет отрисовывать таблицы (как TDrawGrid), простые списки (как TListBox и TCheckListBox), деревья (как TTreeView) с любым количеством элементов, при этом нет никаких проблем с производительностью, никаких тормозов (если вы сами не накосячите при реализации асинхронных обработчиков событий).

#### Компоненты для хранения PNG-иконок <a name="laz-components-png"></a>

В Delphi 2007 мы используем компоненты PNGComponents для отрисовки кнопок с иконками в формате PNG. К счастью, для Лазаруса эти компоненты не требуются, т.к. работа с PNG доступна из коробки (современные версии Delphi также поддерживают PNG из коробки, но для нормального отображения нужно менять одно из свойств в компоненте TImageList). Причем в Лазарусе очень мощная реализация TImageList, позволяющая хранить иконку одновременно в нескольких разрешениях. Компонент автоматически создаст иконки с недостающими разрешениями.

## Подготовка проекта к портированию <a name="laz-prepare-porting-start"></a>

Прежде чем приступить к работе с проектом в Lazarus, необходимо потратить значительное количество времени на подготовительные работы. После проведения таких работ проект по прежнему будет работоспособным для Delphi.

### Преобразование кодировки файлов с исходными кодами в UTF-8 <a name="laz-prepare-porting-codepage"></a>

Необходимо преобрабовать все PAS-файлы в формат UTF-8. Delphi прекрасно понимает как WIN-1251, так и UTF-8, однако Lazarus нормально работает только с UTF-8. Для преобразования в UTF-8 достаточно с помощью редактора кода Delphi вставить в код любой иероглиф и нажать "Сохранить".
Кроме того, необходимо добавить в каждый PAS-файл (рекомендую в самом начале) такой текст: `{$IFDEF FPC}{$CODEPAGE UTF8}{$H+}{$MODE DELPHI}{$ENDIF}`.
Если вы не укажете директиву `{$CODEPAGE UTF8}`, то с высокой долей вероятности столкнётесь с некорректным распознаванием компилятором FPC символов русского языка в текстовых константах.

### Портировать на Lazarus все независимые модули. Убедиться в том, что они работают как на Windows, так и в Linux <a name="laz-prepare-porting-base-units"></a>

Модули, не имеющие зависимости от других модулей проекта, можно рассматривать как независимые. Это значит, что каждый из таких модулей мы можем попытаться скомпилировать в Lazarus, предварительно создав в нём новое приложение. Я начинал процесс портирования именно с этого: предварительно портировал свои библиотечные модули, доступные на github: [ibxFBUtils](https://github.com/loginov-dmitry/ibxfbutils), [LDSLogger](https://github.com/loginov-dmitry/loginovprojects/tree/master/ldslogger), [matrix32](https://github.com/loginov-dmitry/loginovprojects/tree/master/matrix32), [SafeIniFiles](https://github.com/loginov-dmitry/loginovprojects/tree/master/safeinifiles), [SmartHolder](https://github.com/loginov-dmitry/loginovprojects/tree/master/smartholder), [TimeIntervals](https://github.com/loginov-dmitry/multithread/blob/master/CommonUtils/TimeIntervals.pas), [ParamsUtils](https://github.com/loginov-dmitry/multithread/blob/master/CommonUtils/ParamsUtils.pas), [MutexObjectUnit](https://github.com/loginov-dmitry/multithread/blob/master/CommonUtils/MutexObjectUnit.pas), [LDSWaitForm](https://github.com/loginov-dmitry/multithread/tree/master/ExWaitWindow). Кроме того, было портировано несколько десятков различных модулей, используемых в нашем проекте.

### Отделение кода бизнес-логики от графического интерфейса <a name="laz-prepare-porting-split-code"></a>

Рекомендую провести работу по отделению кода бизнес-логики от графического интерфейса. Вы можете считать бизнес-логикой любой код, который напрямую не работует с компонентами графического интерфейса. Благодаря этому вы сможете повторно использовать такой код, если решите реализовать дополнительные версии своего проекта: "служба", "консольное приложение", "UniGui", "FireMonkey", "WEB-сервер" и т.д. Рекомендую выносить код бизнес-логики в отдельные PAS-файлы, при этом необходимо убедиться в том, что в строке `uses` отсутствуют модули, имеющие отношение к GUI (Forms, Controls, Dialogs, Menus, ExtCtrls, Grids, DBGrids, StdCtrls, ComCtrls, Buttons и т.п.). Данное ограничение не имеет отношения к модулю Graphics.

### Избавиться от взаимных (циклических) зависимостей между модулями <a name="laz-prepare-porting-unit-ref"></a>

По хорошему таких зависимостей быть не должно. Если вы объявили какую-то структуру для использования в модуле "A" и возникла необходимость использования этой структуры из модуля "B", то перенесите эту структуру в отдельный независимый модуль "C". Другой пример: если в проекте имеется модуль данных (uDataModule.pas) и в нём имеется ссылка на модуль главной формы (uMainForm.pas), то такую ссылку обязательно нужно удалить и скорректировать код должным образом. Если вы не избавитесь от взаимных зависимостей, то задача портирования под Lazarus будет намного сложнее (учитывая капризы IDE Lazarus, она может оказаться неподъёмной).

### Проверить в Lazarus работоспособность сторонних библиотек и компонентов <a name="laz-prepare-porting-check-components"></a>

Я заранее убедился, что сторонные библиотеки, такие как IBExpress, Graphics32, HTMLViewer, Indy10 и т.п. компилируются с помощью Lazarus как для Windows, так и для Linux (с виджетами GTK2), а также корректно работают.

### Разработать модуль (либо несколько модулей) совместимости типов <a name="laz-prepare-porting-unit-compat-types"></a>

В Лазарусе отсутствуют объявления некоторых типов для Linux. Например, типы WPARAM и LPARAM для Windows объявлены, а для Линукса их объявление может отсутствовать (несмотря на то, что для Линукса имеется реализация функций PostMessage и SendMessage, для которых эти типы были задуманы). Другой пример: в FPC объявлен тип `TLibHandle` (для загрузки динамических библиотек), а в Delphi данное объявление отсутствует. Вам следует завести отдельный модуль, который мы будет называть "модуль совместимости", например "CompatTypes.pas".
В нем, например, вы можете объявить тип TLibHandle таким образом:

```pascal
  {$IFnDEF FPC}
  type 
    TLibHandle = THandle;
  {$ENDIF}
```

Также можете обявить типы WPARAM и LPARAM:

```pascal
  {$IfDef LINUX}
  type 
    LPARAM = NativeUInt;
    WPARAM = NativeUInt;
  {$EndIf}
```

В DELPHI2007 отсутствует тип исключения ENotImplemented, а также типы NativeInt и NativeUInt, поэтому объявляем их в этом же модуле:

```pascal
  {$IFDEF DELPHI2007}
  type
    ENotImplemented = class(Exception);
	NativeInt  = Integer;
    NativeUInt = DWORD;
  {$ENDIF}
```

### Разработать модуль (либо модули) с реализацей отсутствующих для Linux функций <a name="laz-prepare-porting-unit-compat-funcs"></a>

Под Linux отсутствуют многие функции, в том числе GetCurrentProcessId, CoInitialize, CoUninitialize. Если для функции GetCurrentProcessId имеется аналог GetProcessID, то для функций CoInitialize и CoUninitialize аналогов под Linux нет (там отсутсвует поддержка ActiveX / Ole automation). Мы можем отключить вызовы функций CoInitialize и CoUninitialize с помощью условной компиляции, а вызов функции GetCurrentProcessId подправить на GetProcessID также с помощью условной компиляции. Однако при таком подходе вы очень быстро обнаружите, что ваш код становиться всё менее и менее красивым. Я рекомендую завести отдельный модуль, например "CompatFuncs.pas", и в нем реализовать все необходимые отсутствующие функции, например:

```pascal
  {$IfDef LINUX}
  function GetCurrentProcessId:SizeUInt;
  begin
    Result := GetProcessID;
  end;

  procedure CoInitialize(p: Pointer); // Заглушка
  begin
  end;

  procedure CoUninitialize();         // Заглушка
  begin
  end;
  {$EndIf}
```

### Исправить код преобразования типов, не учитывающий 64-битный код <a name="laz-prepare-porting-fix-64"></a>

На Lazarus вы будете разрабатывать 64-битную версию приложения (в 32-битной версии нет никакого смысла), однако в Delphi, вероятно, вы всё ещё разрабатываете 32-битную версию. В этом случае вы должны избавиться от сомнительных преобразований типов. Например, если вы хотите передать в `SendMessage` указатель, то нужно его конвертировать через `WPARAM(p)` либо `LPARAM(p)`, но не через `Integer(p)` и не через `DWORD(p)`.

### Скорректировать объявления THandle <a name="laz-prepare-porting-fix-handle"></a>

В Lazarus функция LoadLibrary возвращает тип TLibHandle. Для Linux очень важно использовать именно этот тип, а не THandle, поскольку THandle в Linux объявлен как 32-битный тип, а функция LoadLibrary возвращает 64-битное значение.

Кроме того, при работе с функциями, которые принимают параметр HDC, необходимо использовать именно этот тип, а не THandle (по тем же причинам).

Рекомендую найти все объявления переменных THandle и убедиться, что в каждом случае это объявление является уместным.

### Подготовьте модули DLL-библиотек к тому, что они могут быть включены в исполняемый файл <a name="laz-prepare-porting-prepare-dll"></a>

Если ваш проект включает в себя DLL-файлы, то убедитесь, что в каждом проекте DLL-библиотеки модули названы уникальным образом. В Delphi мы очень активно для своих проектов используем DLL-файлы, однако, в случае использования Lazarus я рекомендую по возможности включать весь код библиотек в исполняемый файл, поэтому названия PAS-файлов не должны пересекаться.
Причины такой странной рекомендации:
1) Отсутствие поддержки BPL-пакетов в Lazarus (в Delphi мы все проекты компилируем с BPL-библиотеками);
2) Сложность (небольшая) отладки кода DLL-библиотек в Lazarus, особенно на Linux;
3) Сложно перехватывать исключения, возникшие в коде DLL/SO - библиотеки (связано в отсутствием BPL-пакетов);
4) Каждая SO-библиотека в Linux будет весить минимум 20 МБ, хотя большая часть динамических библиотек изначально разрабатывалась ради одного-двух модулей, которые никак не повлияют на размер исполняемого файла, если эти модули подключить к основному проекту.

### Произвести замену некоторых компонентов <a name="laz-prepare-porting-replace-components"></a>

Некоторые компоненты можно заменить на аналоги, доступные и для Delphi и для Lazarus. Например, вы используете компонент TListBox в режиме самостоятельной отрисовки (в обработчике события OnDrawItem). Данный компонент имеется в Lazarus, однако там он не имеет режима самостоятельной отрисовки. Вы можете заменить его на компонент TVirtualStringTree, который доступен также для Lazarus.

Компонент TWebBrowser в ряде случаев можно заменить на THtmlViewer.

### По возможности избавиться от неиспользуемых компонентов, которые недоступны для Лазаруса <a name="laz-prepare-porting-remove-old-components"></a>

Например, вашему проекту более 20 лет и в нём используются компоненты AsyncPro для установки dialup-соединения. Данные компоненты для Лазаруса отсутствуют, однако, возможно уже никто из ваших клиентов такой возможностью не пользуется. В этом случае можно удалить эти компоненты из проекта.

### Избавиться от обработчика события OnDrawDataCell у компонента TDBGrid <a name="laz-prepare-porting-fix-event-drawdatacell"></a>

Если в вашем проекте используется обработчик OnDrawDataCell, то его необходимо переделать его на OnDrawColumnCell, поскольку для Лазаруса отсутствует событие OnDrawDataCell.

### Исправить кодировку текста в базе данных <a name="laz-prepare-porting-fix-db-encode"></a>

Данная рекомендация актуальна для баз данных Firebird. Единственная кодировка текста в БД, с которой у меня не возникло проблем в Линуксе, это UTF8. Но следует учитывать, что для UTF8 Firebird накладывает более жёсткие ограничения на длину поля. Для некоторых полей, в которых хранится большой объём текста (несколько тысяч символов), нам пришлось уменьшать длину поля в объявлении.



## Конвертация форм dfm -> lfm  <a name="laz-convert-forms"></a>

###  Трудности конвертации форм в Лазарусе <a name="laz-convert-forms-problems"></a>

Данный вопрос является одним из наиболее сложных. Необходимо для каждой формы и для каждого модуля данных произвести конвертацию файла ресурсов формы dfm -> lfm. Не нужно думать, что вы сможете обойтись без этого. Даже если Лазарус сможет загрузить имеющийся dfm-файл, он внесёт в него свои изменения, после чего этот файл нельзя будет открыть в Delphi.

Мы не хотим каждую форму заново создавать под Лазарус. Это было бы утопией. Многие формы настолько сложны, что создание заново займёт несколько дней.

В Лазарусе имеется встроенный механизм конвертации приложений, доступный из меню Tools -> Delphi Convertion. Я не исключаю, что данный механизм частично будет работать для вашего проекта, однако мне не удалось им воспользоваться. Данный механизм очень капризный. Для его использования должны быть соблюдены следующие условия:
1) в модуле формы не должно быть никаких модулей в секции `uses`, о которых Лазарус не знает;
2) все компоненты, описанные в dfm-файле, должны быть установлены в палитру компонентов Лазаруса.
Насколько я понял, в процессе конвертации Лазарус пытается найти каждый компонент в палитре и убедиться в наличии необходимых свойств.

Судя по [статье](https://habr.com/ru/articles/534466/) Константина Тимофеева, ему в среде CodeTyphon удалось воспользоваться механизмом конвертации. Вероятно, там данный механизм доработан.

### Разработка собственного инструмента конвертации форм <a name="laz-convert-forms-app"></a>

Мне пришлось реализовать собственное ПО для конвертации форм, а также PAS-файлов. Мой конвертер не является универсальным, он может не подойти для других проектов. Он использует список наименований компонентов и свойств, которые нужно заменить либо удалить. Для простых форм со стандартными компонентами он работает хорошо. Для сложных форм может потребоваться ручная доработка lfm-файла (либо конвертера). Вы легко узнаете о необходимости такой доработки, если попытаетесь открыть lfm-файл в Лазарусе.

В конвертере используется следующий список замен наименований классов:

```pascal
  LReplClass.Add('TJvSpinEdit=TRxSpinEdit');  
  LReplClass.Add('TJvDirectoryEdit=TDirectoryEdit');
  LReplClass.Add('IXMLDocument=TXMLDocument');
  LReplClass.Add('IXMLNode=TDOMNode');
  LReplClass.Add('TMessage=TLMessage');
  LReplClass.Add('TJvMemoryData=TRxMemoryData');
  LReplClass.Add('TPngBitBtn=TBitBtn');
  LReplClass.Add('TPngImage=TImage'); 
  LReplClass.Add('TPngSpeedButton=TSpeedButton');
  LReplClass.Add('TFormStorage=TIniPropStorage:delprops');
  LReplClass.Add('TFormPlacement=TIniPropStorage:delprops');
  LReplClass.Add('TRichEdit=TMemo');
  LReplClass.Add('TPngImageCollection=TImageList:delprops'); 
  LReplClass.Add('TPngImageList=TImageList:delprops');
  LReplClass.Add('TApplicationEvents=TApplicationProperties');
  
  //delprops - удалить все свойства объекта (кроме Left и Top)
```

Список свойств для удаления:

```pascal
  LDelProps.Add('*.Margins');
  LDelProps.Add('*.ExplicitWidth');
  LDelProps.Add('*.ExplicitHeight');
  LDelProps.Add('*.ExplicitLeft');
  LDelProps.Add('*.ExplicitTop');
  LDelProps.Add('*.TextHeight');
  LDelProps.Add('*.AlignWithMargins');
  LDelProps.Add('*.OldCreateOrder');
  LDelProps.Add('*.PngImage');
  LDelProps.Add('*.DesignSize');
  LDelProps.Add('TJvDirectoryEdit.DialogKind');
  LDelProps.Add('TDirectoryEdit.DialogKind');
  LDelProps.Add('TButton.WordWrap');
  LDelProps.Add('TPanel.BevelEdges');
  LDelProps.Add('TCheckBox.WordWrap');
  LDelProps.Add('TIBStringField.FixedChar');
  LDelProps.Add('TDateTimePicker.Format');
  LDelProps.Add('TPanel.BevelKind');
  LDelProps.Add('TRxSpinEdit.DisplayFormat');
  LDelProps.Add('TFormPlacement.OnSavePlacement');
  LDelProps.Add('TFormPlacement.OnRestorePlacement');
  LDelProps.Add('TTabSheet.Constraints');
  LDelProps.Add('TRadioButton.WordWrap');
  LDelProps.Add('TScrollBox.BevelInner');
  LDelProps.Add('TScrollBox.BevelOuter');
  LDelProps.Add('TStringGrid.BevelInner');
  LDelProps.Add('TStringGrid.BevelKind');
  LDelProps.Add('TStringGrid.BevelOuter');
  LDelProps.Add('TTreeView.Items.NodeData');
  LDelProps.Add('TListBox.OnData');     
```                                          

Список свойст для замены:

```pascal
LReplProps.Add('*.Padding=BorderSpacing'); 
```

Список названий модулей для замены:

```pascal
  LReplUnits.Add('Windows=LCLIntf,LCLType');
  LReplUnits.Add('Messages=LMessages');  
  LReplUnits.Add('TeEngine=TAGraph,TASeries');
  LReplUnits.Add('Series=TAGraph,TASeries');
  LReplUnits.Add('TeeProcs=TAGraph,TASeries');
  LReplUnits.Add('Chart=TAGraph,TASeries');
  LReplUnits.Add('Mask=MaskEdit');
  LReplUnits.Add('JvExMask=MaskEdit');
  LReplUnits.Add('JvToolEdit=EditBtn');
  LReplUnits.Add('JvSpin=del');
  LReplUnits.Add('JvMemoryDataset=RxMemDS');  
  LReplUnits.Add('ToolEdit=EditBtn');  
  LReplUnits.Add('Placemnt=IniPropStorage');
  LReplUnits.Add('PngBitBtn=Buttons');
  LReplUnits.Add('PngSpeedButton=Buttons');
  LReplUnits.Add('PngImageList=del');
  LReplUnits.Add('PngFunctions=del');
  LReplUnits.Add('pngimage=Graphics');    
  LReplUnits.Add('jpeg=Graphics');    
  LReplUnits.Add('ActiveX=del');
  LReplUnits.Add('XMLDoc=XMLRead');
  LReplUnits.Add('XMLIntf=DOM');
  LReplUnits.Add('WinSvc=JwaWinSvc');
  LReplUnits.Add('AppEvnts=del');
  
  // del - необходимо удалить объявление модуля для Lazarus
```

К сожалению мне не удалось реализовать конвертацию свойств и кода для графиков TChart, поскольку расхождений с TeeChart в Лазарусе очень много. Если в вашем приложении активно используются компоненты TChart, то заложите несколько дней на разработку параллельной реализации кода работы с графиками.
Либо, если вы приобретали компоненты TeeChart Pro, то можно скорректировать их исходный код таким образом, чтобы графики работали в Лазарусе, как это описано в [статье](https://habr.com/ru/articles/534466/).

### Привязка компонентов на форме <a name="laz-convert-forms-anchor-editor"></a>

При визуальной разработке формы для VCL-приложения в Delphi мы сразу видим, как наша форма будет выглядеть в запущенной программе. Даже если у заказчика будет монитор с высокой плотностью пикселя, VCL автоматически откорректирует размеры визуальных элементов, сохранив их взаимное расположение. В Delphi, как правило, не требуется взаимная привязка компонентов другу к другу, достаточно имеющихся механизмов выравнивания (Align, AlignWithMargins, Anchors, Margins, Padding). В редких случаях взаимную привязку можно реализовать с помощью дополнительного кода.

Для Лазаруса требуется дополнительная привязка компонентов относительно друг друга, особенно, если ваше ПО должно работать в ОС Linux. Это связано с тем, что в ОС Linux высота некоторых элементов (например, TEdit, TCombobox) по умолчанию является непредсказуемой. Если вы разработаете форму в ОС Windows, а затем скомпилируете и запустите ваше ПО в Линуксе, то форма будет выглядеть безобразно, элементы будут налазить друг на друга.

Для привязки компонентов необходимо использовать менеджер (редактор) привязок, который открывается с помощью меню "View / Anchor Editor" (выше было указано, как встроить его в основное окно IDE Lazarus). 

Подробная инструкция по использованию редактора привязок представлена в документации [здесь](https://wiki.lazarus.freepascal.org/Autosize_/_Layout) и [здесь](https://wiki.lazarus.freepascal.org/Anchor_Sides).

Редактор привязок является весьма мощным инструментом, позволяющим быстро настроить как взаимную привязку компонентов, так и отступы между компонентами. Но вам придётся с этим инструментом разобраться. Будьте готовы к тому, что вам придётся провести с данным инструментом несколько дней или недель (в зависимости от количества компонентов на формах вашего приложения). В среднем у меня получалось около 30 минут на каждую форму, при этом на самые простые формы уходило порядка 10 минут, а со сложными приходилось сражаться по несколько дней.

Замечания по использованию редактора привязок:
1. Старайтесь периодически сохранять изменения в редактируемом модуле, т.к. при малейшей ошибке с вашей стороны IDE Lazarus может зависнуть или закрыться;
2. Работать с редактором привязок удобнее в Линуксе, поскольку вы сразу увидите все места, для которых требуется участие редактора привязок;
3. Привязка компонентов для сложной формы может занять очень много времени (несколько часов или дней). После того, как вы проделаете эту работу, вам не захочется второй раз выполнять конвертацияю dfm -> lfm для такой сложной формы.

### Совместное редактирование форм в Delphi и Lazarus <a name="laz-convert-forms-joint-editing"></a>

При внесении любого изменения на форме в Delphi старайтесь сразу же вносить аналогичное изменения в Лазарусе. Например, если вы добавили кнопку MyButton в редакторе формы в IDE Delphi, то следует точно такую же кнопку с тем же названием добавить в редакторе формы в IDE Lazarus. Если вы забудете добавить эту кнопку в Лазарусе, то приложение скомпилируется без замечаний, однако при попытке обратиться к переменной MyButton из когда возникнет ошибка Access Violation, поскольку объект кнопки не был создан.

Проблема с совместным редактированием формы заключается в том, что модуль формы (pas-файл) является общим и для Delphi и для Lazarus. Каждый из них старается внести свои изменения в модуль формы. Рекомендую чаще сохранять модуль формы в хранилище системы контроля версий, чтобы не потерять важные изменения.

### Использование директив условной компиляции для корректировки объявлений используемых компонентов <a name="laz-convert-forms-directives"></a>

Для некоторых компонентов в Лазарусе отсутствует аналог либо он имеет другое название класса.

Например, в Delphi имеется компонент TApplicationEvents. В Лазарусе имеется аналогичный компонент, но он называется TApplicationProperties. В обоих случая присутствуют события OnError и OnHint. В этом случае объявление компонента в модуле формы может выглядеть следующим образом:

```pascal
  TMainForm = class(TForm)
    ApplicationEvents1: {$IFnDEF FPC}TApplicationEvents{$ELSE}TApplicationProperties{$ENDIF};
```

Ещё примеры:

```pascal
    btnOK: {$IFnDEF FPC}TPngBitBtn{$ELSE}TBitBtn{$ENDIF};
	VirtMsgList: {$IFnDEF FPC}TVirtualStringTree{$ELSE}TLazVirtualStringTree{$ENDIF};
```

## Подключение стороннего менеджера памяти <a name="laz-mem-manager"></a>

Менеджер памяти, входящий в комплект FPC/Lazarus, вполне подходит для разработки десктопных программы. Однако, если вы разрабатываете серверное ПО, которое должно постоянно поддерживать сотни и тысячи TCP-соединений с клиентским ПО, вероятно, лучшим решением окажется [менеджер памяти](https://github.com/synopse/mORMot2/blob/master/src/core/mormot.core.fpcx64mm.pas) от автора библиотеки [mORMot2](https://github.com/synopse/mORMot2) Arnaud Bouchez. В любом случае, лучше сравнить оба менеджера памяти на реальном проекте по следующим критериям:
1) производительность (количество операций выделения/освобождения блоков памяти различного размера в секунду) для одного потока;
2) производительность для нескольких потоков (количество потоков не должно превышать количеству ядер процессора и лучше избегать процессоры с гипертредингом, поскольку результаты будут искажены);
3) объём потребления памяти ОЗУ (в том числе зависимость потребления ОЗУ от количество потоков).

Менеджер памяти в Лазарусе образа 2017 года отличался очень высоким потреблением ОЗУ (несколько мегабайт ОЗУ для каждого потока).

Для подключения стороннего менеджера памяти достаточно указать каталог с модулем в параметрах проекта (Project options \ Compiler options \ Paths \ Other unit files) и указать модуль менеджера памяти в файле проекта (`*.lpr`) самым первым в списке `uses`, сразу после модуля `cthreads`, например, следующим образом:

```pascal
program MyProgram;
uses
  {$IFDEF UNIX}
  cthreads,
  {$ENDIF} 
  mormot.core.fpcx64mm;
```

## Подключение общего менеджера памяти в DLL-библиотеку <a name="laz-mem-manager-dll"></a>

Выше упоминались некоторые проблемы, связанные с разработкой DLL/SO-библиотеки в Лазарусе. Однако, если вы решили, что вам не обойтись без DLL/SO-библиотеки, вам необходимо выполнить три вещи:

1. Подключить модуль cthreads (для Linux) самым первым в файле проекта (`*.lpr`), например, следующим образом:

```pascal
program MyLibrary;
uses
  {$IFDEF UNIX}
  cthreads,
  {$ENDIF} 
  .....;
```

Если этого не сделать, то многопоточный код не сможет исполняться в SO-библиотеке (в Linux) должным образом.

2. Перенести директиву `exports`, в которой перечислены наименования экспортируемых функций, в файл проекта (`*.lpr`). Если этого не сделать, то директивы `exports`, указанные в других модулях проекта, учитываться не будут.

3. Если между исполняемым модулем и библиотекой будут передаваться переменные с управляемым временем жизни (строки, динамические массивы), то необходимо в библиотеке произвести установку менеджера памяти (с помощью функции SetMemoryManager), запрошенного из исполняемого модуля (с помощью функции GetMemoryManager). Это абсолютно необходимо сделать, если вы подключили к исполняемому модулю сторонний менеджер памяти. Но даже если вы не подключали сторонний менеджер памяти, то я всё равно рекомендую произвести данную операцию, т.к. это увеличит производительность менеджера памяти и полностью снимает вопрос "Каким образом исполняемый модуль и библиотека нормально работают с разными экземплярами стандартного менеджера памяти?" (оно реально работает, даже для многопоточного приложения).

Установка менеджера памяти в библиотеке заключается в том, что библиотека при загрузке должна запросить у исполняемого модуля ссылку на его менеджер памяти и установить его в качестве собственного менеджера памяти, в результате чего у исполняемого модули и у библиотеки будет один общий экземпляр менеджера памяти.

### Действия по установке общего менеджера памяти в библиотеке <a name="laz-mem-manager-dll-steps"></a>

1. Добавить в файл проекта исполняемого модуля (`*.lpr`) директиву экспорта функции GetMemoryManager следующим образом:

```pascal
  exports
    GetMemoryManager name 'FPC_GetMemoryManager';
```

2. Добавить к проекту библиотеки дополнительный модуль (например, LazMMInit.pas). В него добавить следующий код:

```pascal
	{$MODE Delphi}{$H+}{$CODEPAGE UTF8} 

	unit LazMMInit;

	interface

	uses
	  {$IFDEF UNIX}cthreads,{$ENDIF} // Требуется для многопоточной работы
	  dynlibs;

	implementation

	var
	   NewMM:      TMemoryManager;
	   MainHandle: TLibHandle;
	   GetCommonMemoryManager: procedure(var aMemMgr: TMemoryManager);


	procedure LoadEXEMemoryManager;
	var
	  NewGetMem, OldGetMem: PtrUInt;
	  sTmp, sExeFile: string;
	begin
	  sExeFile := ParamStr(0);
	  MainHandle := dynlibs.LoadLibrary(sExeFile);
	  sExeFile := '';
	  if MainHandle = 0 then
		Exit;

	  GetCommonMemoryManager := dynlibs.GetProcAddress(MainHandle, 'FPC_GetMemoryManager');
	  if Assigned(GetCommonMemoryManager) then
	  begin
		GetCommonMemoryManager(NewMM); // Запрашиваем менеджер памяти из EXE
		SetMemoryManager(NewMM);
	  end;
	end;

	initialization
	  LoadEXEMemoryManager;

	finalization
	  //SetMemoryManager(OldMM); - нельзя, т.к. возникают ошибки при выгрузке DLL
	end.
```

3. Указать модуль LazMMInit самым первым в списке модулей `uses` в файле проекта библиотеки, например:

```pascal
	uses
	  LazMMInit,
	  Classes, 
	  ...
```
 
### Корректная выгрузка библиотеки с помощью FreeLibrary <a name="laz-mem-manager-freelibrary"></a>

Если вы установили в библиотеке общий менеджер памяти, то вы обязаны явно вызвать функцию FreeLibrary при завершении работы вашей программы (иначе будут возникать ошибки при выходе из программы).


## Обработка исключений, возникающих в DLL/SO-библиотеке <a name="laz-dll-exceptions"></a>

Если ваш исполняемый модуль вызвал функцию, реализованную в библиотеке и в ней возникло исключение (exception), то будут сложности с перехватом этого исключения. Следующий код не сможет перехватить исключение:

```pascal
  try
    вызов функции из библиотеки
  except
    on E: Exception do
	begin
	  // Это код выполнен не будет
	end;
  end;
```

Связано это с тем, что в исполняемом модуле и в библиотеке находятся разные экземпляры классов исключений (класс `Exception` и его наследники). В Delphi с этим проблем у нас нет, поскольку все наши модули скомпилированы с BPL-пакетами, которые содержат все общие классы, в том числе `Exception`.

К счастью, сам механизм перехвата исключений (кроме разницы в экземплярах классов) прекрасно работает. 

Для успешного перехвата исключения необходимо объявить типы `TExceptionMessage`, `TExceptionDesc` и реализовать вспомогательные функции `ObjectIsException`, `GetEObjectDesc` следующим образом:

```pascal
type
  TExceptionMessage = record
    Message: string;
  end;

  TExceptionDesc = record
    ExceptionClassName: string;
    ExceptionObj: TObject; // Оригинальный объект исключения
    E: TExceptionMessage;  // Текст исключения (через E.Message)
    ExceptionClass: ExceptClass;
  end;
  
function ObjectIsException(o: TObject): Boolean;
var
  c: TClass;
begin
  Result := False;
  if Assigned(o) then
  begin
    c := o.ClassType;

    while (Assigned(c) and (c.ClassParent <> nil)) do
    begin
      if c.ClassName = 'Exception' then
      begin
        Result := True;
        Exit;
      end;

      c := c.ClassParent;
    end;
  end;
end;  

function GetEObjectDesc: TExceptionDesc;
var
  p : TObject;
begin
  p := TObject(AcquireExceptionObject);

  Result.ExceptionClassName := p.ClassName;

  if p is Exception then
    Result.E.Message:=Exception(p).Message
  else if p is TObject then
    Result.E.Message:={$IFDEF FPC}p.ToString{$ELSE}p.ClassName{$ENDIF}
  else if ObjectIsException(p) then // Если объект исключения создан в чужом runtime
    Result.E.Message:=Exception(p).Message
  else
    Result.E.Message:='unknown exception object';

  if p is Exception then
    Result.ExceptionClass := ExceptClass(p.ClassType)
  else
  begin
    // Заменяем на аналогичный класс, который известен в текущем runtime
    Result.ExceptionClass := Exception;
  end;

  Result.ExceptionObj := p;

  ReleaseExceptionObject;
end;
```

Пример кода с перехватом исключения, возникшего в библиотеке:

```pascal
  try
    вызов функции из библиотеки
  except
    with GetEObjectDesc do
	begin
	  Log('Возникла ошибка: ' + E.Message);
	  raise EMyException.Create(E.Message); // "Регенерация" исключения
	end;
  end;
```

Данный код является универсальным. В каком бы месте исключение не возникло (в исполняемом модуле или в библиотеке), оно будет перехвачено и записано в лог.
Для регенерации исключения в данном примере используется явный класс `EMyException`, поскольку исходный класс исключения, возникшего в библиотеке, мы не знаем (функция`GetEObjectDesc` не сохраняет класс исключения, если оно возникло в библиотеке). Эту проблему частично можно решить следующим образом: завести список зарегистрированных классов исключений и выполнять поиск класса исключения по его имени в функции `GetEObjectDesc`. Но полноценно проблема будет решена только при внедрении в FPC механизма, аналогичного BPL-пакетам.

## Особенности обработки строк UTF-8 в Lazarus <a name="laz-strings"></a>

При разработке приложения в Лазарусе следует исходить из того, что все строки по умолчанию закодированы в UTF-8 (от 1 до 4х байтов на символ). Строки в кодировке UTF-8 идентичны строкам в старых версиях Delphi (до D2007 включительно), если используется только латинский алфавит. Видимо, по этой причине мы не столкнулись с необходимостью корректировать код для обработки строк. Пришлось скорректировать код буквально в нескольких местах, там, где выполняется поиск по русским символам.

Если ваш код выполняет парсинг XML-файла (либо HTML-файла) и все тэги названы латинскими буквами, то код скорее всего останется без изменений. Также проблем с посимвольной обработкой не будет, если вы используете тип UnicodeString либо WideString (но для Delphi лучше использовать родной UnicodeString).

Пример функции `IsRussianChar`, возвращающей True, если переданный в неё символ является русским:

```pascal
function IsRussianChar(AChar: {$IFnDEF FPC}Char{$ELSE}WideChar{$ENDIF}): Boolean;
var
  sRusChars: {$IFnDEF FPC}string{$ELSE}WideString{$ENDIF};
  I: Integer;
begin
  Result := False;
  sRusChars := 'абвгдеёжзийклмнопрстуфхцчшщьыъэюяАБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЬЫЪЭЮЯ';
  for I := 1 to Length(sRusChars) do
    if sRusChars[I] = AChar then
    begin
      Result := True;
      Exit;
    end;
end;
```

Данный код работает корректно только если в начале pas-файла указана директива `{$CODEPAGE UTF8}`.

Разумеется, можно организовать цикл с использованием вспомогательных функций `UTF8Length` и `UTF8Copy`, однако такой код будет выполняться дольше, т.к. функция `UTF8Copy` производит поиск символа с указанным индексом каждый раз с начала строки.