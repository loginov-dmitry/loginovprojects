<HTML><HEAD>
<META content="text/html; charset=windows-1251" http-equiv=Content-Type>
<META name=EDITORORG content="Russia, Penza, LTD AUTOMATIKA plus, www.automatikaplus.ru">
<META name=GENERATOR content="MSHTML 8.00.7600.16385"></HEAD>
<BODY bgColor=#ffffff text=#000000>

<H1>Замечания по потокобезопасной работе с базами данных</H1>
<P>Версия от 20.05.2011 <BR><BR></P>
<P>Статья посвящена выявлению и&nbsp;решению проблем, возникающих при разработке многопоточного приложения, предназначенного&nbsp;для работы с базой данных (БД). Статья ориентирована главным образом на Delphi-программистов, использующих в своих приложениях для работы с БД&nbsp;обычные компоненты, такие как TXXXConnection / TXXXDataBase, TXXXDataSet /&nbsp;TXXXQuery / TXXXTable, TDataModule / TRemoteDataModule&nbsp;и т.д. Кроме того,&nbsp;представлены практические&nbsp;советы, позволяющие повысить надежность программного обеспечения, ориентированного на работу с&nbsp;БД&nbsp;FireBird. Статью нельзя считать оконченной, поскольку&nbsp;настоящее количество всевозможных проблем в данной области никому не известно. При необходимости данная статья будет дорабатываться.&nbsp;Если считаете необходимым, то Вы можете в этом процессе&nbsp;участвовать.&nbsp;</P>
<H2>Предисловие</H2>
<P>Сообщения о проблемах,&nbsp;возникающих при разработке многопоточного приложения,&nbsp;предназначенного для работы с БД,&nbsp;появляются в профессиональных&nbsp;Delphi-форумах&nbsp;с неизменной периодичностью. Прежде чем браться за реализацию подобного&nbsp;многопоточного приложения, необходимо ознакомится с проблемами, которые с высокой вероятностью могут возникнуть, а также придерживаться определенных привил. Ниже представлена более&nbsp;подробная информация.</P>
<H2>1.&nbsp;Нельзя одновременно из нескольких потоков работать с одним компонентом-подключением!</H2>
<P>Речь идет о компонентах&nbsp;(наследниках TCustomConnection), через которые организовано подключение к базе данных. К ним относятся TIBDataBase, TDataBase, TADOConnection и др. Ниже приведена информация, в которой подробно описаны причины данного ограничения.</P>
<OL type=i>
<LI><STRONG><EM>Что произойдет, если в двух параллельных потоках Т1 и Т2 создать по одному&nbsp;компоненту TIBDataSet (DS1 и DS2) и одновременно присоединить их к компоненту-подключению IBdb: TIBDataBase?</EM></STRONG> Т.е. одновременно выполнить код DS1.Database := IBdb&nbsp;и DS2.Database := IBdb? Будет выполнена следующая цепочка вызовов:<BR>
<UL>
<LI><FONT color=#000080>procedure TIBCustomDataSet.SetDatabase(Value: TIBDatabase);</FONT></LI>
<LI><FONT color=#000080>procedure TIBSQL.SetDatabase(Value: TIBDatabase);</FONT></LI>
<LI><FONT color=#000080>procedure TIBBase.SetDatabase(Value: TIBDatabase);</FONT></LI>
<LI><FONT color=#000080>function TIBDatabase.AddSQLObject(ds: TIBBase): Integer; </FONT>
<LI><FONT color=#000080>procedure TCustomConnection.RegisterClient(Client: TObject; Event: TConnectChangeEvent = nil);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FClients.Add(Client);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FConnectEvents.Add(TMethod(Event).Code);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if Client is TDataSet then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FDataSets.Add(Client);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end;</FONT><BR>Выполняется обращение к объектам: </LI></UL>
<UL>
<LI><FONT color=#000080>FClients: TList; </FONT>
<LI><FONT color=#000080>FDataSets: TList; </FONT>
<LI><FONT color=#000080>FConnectEvents: TList.</FONT></LI></UL>
<P>Очевидно, существует вероятность, что из потоков Т1 и Т2 одновременно будет&nbsp;вызван код: FClients.Add(Client). Известно совершенно точно, что методы&nbsp;объекта TList не являются потокобезопасными. Нельзя одновременно из нескольких&nbsp;потоков вызывать метод TList.Add() для одного и того же объекта TList. В&nbsp;некоторых случаях, если повезёт, вы сразу получите сообщение об ошибке&nbsp;(например Access Violation at address XXXXXX), но может и не будет никакого&nbsp;сообщения - приложение может просто начать глючить.</P></LI>
<LI><STRONG><EM>Что произойдет при одновременном вызове DS1.Open и DS2.Open, подключенных&nbsp;к одному компоненту IBdb?</EM></STRONG>&nbsp;Для ответа на этот вопрос необходимо самым тщательным образом проанализировать исходные коды компонентов, которые Вы используете для работы&nbsp;с БД.&nbsp;Я предпочитаю СУБД&nbsp;FireBird и библиотеку компонентов IBX.&nbsp;Анализ&nbsp;исходных&nbsp;кодов библиотеки IBX, входящей в комплект&nbsp;Delphi 2010,&nbsp;вселяет уверенность, что проблем никаких не возникнет. Однако&nbsp;за предыдущие версии IBX не ручаюсь. Более того, старые версии клиентской&nbsp;библиотеки&nbsp;GDS32.DLL (fbclient.dll) не допускали работу с одним подключением из разных&nbsp;потоков (это заканчивалось ошибками, причем самыми разными). Данное ограничение исправлено в FireBird 2.5. Но если у вас возникла задача одновременного обращения к одному подключению из разных потоков -&nbsp;еще раз подумайте! Ваше приложение может без нареканий работать на компьютере с одноядерным процессором. Проблемы, как правило, начинаются при запуске программы на многоядерном процессоре. Возможно, наиболее простым способом решения проблемы для Вас окажется&nbsp;использование пула подключений. Говоря простым языком, пул подключений -&nbsp;это обычный список TObjectList, в которым хранятся ссылки на&nbsp;установленные подключения (например,&nbsp;созданные компоненты&nbsp;TIBDataBase). Подключение может извлекаться из пула, а также возвращаться в пул. <BR>Вместо традиционного&nbsp;кода:<BR><FONT color=#000080>&nbsp;&nbsp;&nbsp;&nbsp; IBdb := TIBDataBase.Create;<BR>&nbsp;&nbsp;&nbsp; &nbsp;IBdb.DatabaseName := &lt;строка подключения&gt;<BR>&nbsp;&nbsp; &nbsp; IBdb.Params... // настройка параметров подключения и т.п.<BR>&nbsp;&nbsp; &nbsp; IBdb.Connected := True;</FONT><BR>достаточно вызвать одну функцию:<BR>&nbsp;&nbsp; &nbsp; <FONT color=#000080>IBdb := GetDataBaseFromPool(&lt;строка подключения&gt;, &lt;параметры подключения&gt;);</FONT><BR>Данная функция при необходимости создает новое подключение&nbsp;или,&nbsp;если в пуле подключений уже есть свободные подключения,&nbsp;возвращает одно из них, при этом помечает подключение как "активное". <BR>Вместо кода:<BR><FONT color=#000080>&nbsp; IBdb.Connected := False;<BR>&nbsp; IBdb.Free;</FONT><BR>достаточно вызвать одну функцию:<BR>&nbsp; <FONT color=#000080>PutDataBaseToPool(IBdb);</FONT><BR>Данная функция при необходимости закрывает все открытые наборы данных, завершает активные транзакции и помечает подключение как "свободное". При этом не&nbsp;рекомендуется извлекать подключение из пула на длительное время. Как только потребность в подключении отпала, следует&nbsp;без излишнего промедления&nbsp;вернуть его в пул. За счет этого подключения не будут накапливаться в пуле в большом количестве, даже если<BR>ваше приложение активно работает с базой данных&nbsp;(на практике в&nbsp;пуле будет не более 5 подключений). Рекомендуется контролировать размер пула и своевременно закрывать подключения, которые не были востребованы длительное время.</LI></OL>
<H2>2. При работе с FireBird нельзя одновременно из нескольких потоков выполнять подключения к БД!</H2>
<P>Операции подключения и отключения должны быть синхронизированы с помощью любого объекта синхронизации (мьютекс, семафор, эвент, но проще всего - критическая секция) или выполняться в основном потоке. Рекомендую использовать критическую секцию, например:<BR><FONT color=#000080>&nbsp;&nbsp; &nbsp; cs.Enter;<BR>&nbsp;&nbsp; &nbsp; try<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; IBdb.Connected := True // или False<BR>&nbsp;&nbsp; &nbsp; finally<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; cs.Leave;<BR>&nbsp;&nbsp; &nbsp; end;</FONT><BR>Необходимо&nbsp;следить, чтобы коннекты и дисконнекты не выполнялись автоматически (например при вызове TIBDataSet.Open). Ими следует управлять явно! Несмотря на то, что последние версии клиентской библиотеки (начиная с FB2.5) стали намного устойчивее к одновременным подключениям (в&nbsp;<STRONG><EM>десятки</EM></STRONG> раз устойчивей, чем, например,&nbsp;клиентская библиотека от FB2.0), однако лучше перестраховаться путем использования объекта синхронизации. Например, на компьютере может&nbsp;оказаться установленной клиентская библиотека GDS32.dll от старого FireBird (бывает еще хуже - от InterBase). <BR>Во избежание подобных проблем, рекомендую поставлять клиентскую библиотеку GDS32.dll и файл сообщений firebird.msg вместе со своим ПО. Для того, чтобы гарантированно&nbsp;заставить IBX использовать "правильную" библиотеку GDS32.dll, следует&nbsp;разместить ее в каталоге своего приложения, либо заранее загружать её ДО любого обращения к IBX с помощью следующего кода&nbsp;кода:<BR><FONT color=#000080>&nbsp; initialization<BR>&nbsp;&nbsp;&nbsp; LoadLibrary('C:\MyProg\Firebird\GDS32.dll');</FONT><BR>здесь же&nbsp;рекомендуется установить&nbsp;переменную окружения "FIREBIRD":<BR><FONT color=#000080>&nbsp;&nbsp;&nbsp; SetEnvironmentVariable('FIREBIRD', 'C:\MyProg\Firebird\');</FONT><BR>Переменная окружения FIREBIRD указывает клиентской библиотеке GDS32.dll&nbsp;каталог, в котором находятся файлы: firebird.msg, firebird.log, firebird.conf.<BR>Наиболее важным для GDS32.dll является файл firebird.msg, в котором хранятся тексты сообщений об ошибках. Проблема в том, что на компьютере может оказаться&nbsp;несколько версий FireBird (на практике такое происходит очень часто), и, если явно не указать переменную "FIREBIRD", то библиотека GDS32.dll может подгрузить "чужие" сообщения об ошибках, что приведет к реальным проблемам в том случае, если логика вашего приложения зависит от точной формулировки тех или иных сообщений об ошибках.</P>
<H2>3. При использовании Delphi 7 (или более старой версии) необходимо обновить библиотеку IBX.</H2>
<P>Скачать IBX для Delphi 7&nbsp;можно здесь <A href="http://ibase.ru/ibx/ibxdp711.zip">http://ibase.ru/ibx/ibxdp711.zip</A>. Компоненты IBX в стандартной поставке Delphi 7 нельзя использовать в условиях <BR>многопоточности! Одна из&nbsp;основных&nbsp;причин заключается в том, что при создании TIBDataBase осуществлялось создание объекта TTimer, который <STRONG><EM>нельзя</EM></STRONG> создавать из дополнительного потока! Действительно, при создании объекта TTimer будет выполнена следующая цепочка вызовов:<BR><FONT color=#000080>&nbsp;&nbsp;&nbsp;&nbsp; - constructor TTimer.Create(AOwner: TComponent);<BR>&nbsp;&nbsp;&nbsp;&nbsp; - function AllocateHWnd(AMethod: TWndMethod): HWND (модуль Classes);<BR>&nbsp;&nbsp;&nbsp;&nbsp; -&nbsp;function MakeObjectInstance(AMethod: TWndMethod): Pointer (модуль Classes);</FONT><BR>Посмотрев внимательно на реализацию MakeObjectInstance мы обнаружим, что в данном коде отсутствует какая-либо защита от параллельных вызовов. Одновременные обращения к функции MakeObjectInstance зачастую приводят к полному зависанию приложения, либо к трудноуловимым ошибкам.</P>

</BODY></HTML>
