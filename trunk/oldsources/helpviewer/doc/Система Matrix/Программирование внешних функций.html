<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<TITLE> Программирование внешних функций </TITLE>
<META NAME="Generator" CONTENT="EditPlus">
<META NAME="Author" CONTENT="Логинов Д.С.">
<META NAME="Keywords" CONTENT="Matrix">
<META NAME="Description" CONTENT="Программирование внешних функций">
</HEAD>

<BODY>
<H1 align=center><I>Программирование внешних функций</I></H1>
<font style="font-family: courier new;"><I>
<P>Внешними функциями будем называть все подпрограммы, находящиеся вне модуля Matrix.pas. Такие функции отличаются тем, что в них среди входных параметров обязательно присутствует ссылка на рабочую область, содержащую входные данные. Внешние функции могут быть двух видов:<BR>
1 - с собственной рабочей областью;<BR>
2 - без собственной рабочей области.

<P>Функции первого типа во время работы создают временную рабочую область, в которую передаются все входные массивы под определенными именами, после чего обработка массивов выполняется независимо от других рабочих областей. В конце работы такие функции перемещают массивы-результаты в указанную (в параметрах) рабочую область, после чего рабочая область функции уничтожается.
<P>Функции второго типа не создают собственной рабочей областью, а используют рабочую область, указанную в параметрах. К преимуществам функций данного типа следует отнести несколько более высокую скорость обработки, т.к. не нужно выполнять копирование входных массивов и возвращать выходные массивы. Недостатком таких функций является неудобство работы с ними: приходится придерживаться уникальности имен массивов, вследствие чего имена всех временно создаваемых функцией массивов должны быть сгенерированы с помощью функции <A HREF="../Функции ядра/GenName.html"><B>GenName()</B></A>, а в конце работы функции все временные массивы должны быть удалены. При работе с функциями первого типа таких проблем не возникает.

<P>Рассмотрим правила программирования внешних функций с собственной рабочей областью. Работающие примеры таких функций вы можете посмотреть в модуле <B>Signals.pas</B>.
Создадим простейшую внешнюю функцию, которая складывает два массива 'A' и 'B' и умножает результат сложения на третий массив 'C'. На выходе функции формируется массив 'D'.<BR><BR></I>

<pre>
<b>procedure</b> ExternalFunc(Ws: TWorkspace; A, B, C, D: <b>string</b>);
<b>begin</b>
  <b>with</b> TWorkspace.Create(<span style="color: navy;">'ExternalFunc'</span>) <b>do</b> <b>begin</b> <i style="color: navy;">// Создание рабочей области</i>
    CheckResAr(D); <i style="color: navy;">// Проверка правильности имени выходного массива</i>
    CopyRefFromWorkspace(Ws, A, <span style="color: navy;">'A'</span>); <i style="color: navy;">// Передача ссылки на массив А</i>
    CopyRefFromWorkspace(Ws, B, <span style="color: navy;">'B'</span>); <i style="color: navy;">// Передача ссылки на массив В</i>
    CopyRefFromWorkspace(Ws, C, <span style="color: navy;">'C'</span>); <i style="color: navy;">// Передача ссылки на массив С</i>
    ElWiseOp(<span style="color: navy;">'A'</span>, <span style="color: navy;">'B'</span>, <span style="color: navy;">'Tmp'</span>, <span style="color: navy;">'+'</span>);   <i style="color: navy;">// A + B = Tmp</i>
    ElWiseOp(<span style="color: navy;">'Tmp'</span>, <span style="color: navy;">'C'</span>, <span style="color: navy;">'D'</span>, <span style="color: navy;">'*'</span>);   <i style="color: navy;">// Tmp * C = D</i>

    <i style="color: navy;">// Предыдущие две строки можно свернуть в одну, как показано ниже:</i>
    <i style="color: navy;">// ElWiseOp(ElWiseOp('A', 'B', 'Tmp', '+'), 'C', 'D', '*');</i>

    MoveToWorkspace(Ws, <span style="color: navy;">'D'</span>, D);      <i style="color: navy;">// Передача D в целевую рабочую область</i>
    Free;                             <i style="color: navy;">// Уничтожение рабочей области</i>
  <b>end</b>;
<b>end</b>;
</pre>
<br><I>

<P>В первой строке находится заголовок подпрограммы. Параметры A, B и С соответствуют входным массивам, параметр D соответствует выходному массиву, Ws - ссылка на рабочую область. Именно рабочая область Ws содержит все входные массивы и в нее же необходимо передать полученный выходной массив 'D'.
<P>Комментарии подробно раскрывают смысл каждой строки текста. В самом начале процедуры происходит создание рабочей области. Оператор <B>with</B> позволяет не объявлять переменную класса TWorkspace. Если в вашей подпрограмме должна вызываться другая подпрограмма, то в качестве ссылки на рабочую область достаточно передать указатель <B>SelfWS</B>.
<P>Сформулируем несколько правил, которых желательно придерживаться для того, чтобы программируемые вами функции были максимально простыми, понятными и быстрыми.
<UL>
	<LI>В заголовке функции ссылка на рабочую область должна стоять на первом месте, после чего должны следовать входные массивы, выходные массивы и дополнительные параметры;
	<LI>При передаче массивов в подпрограмму предпочтительнее использовать функцию CopyRefFromWorkspace() вместо функции CopyFromWorkspace(). Вторую функцию есть смысл использовать только в тех случаях, когда для более краткой записи кода происходит модификация элементов в переданном массиве;
	<LI>Результаты работы подпрограммы следует возвращать с помощью функции MoveToWorkspace();
	<LI>Тело подпрограммы должно находиться внутри оператора <B>with</B>. В конце оператора with должен стоять вызов метода Free(), необходимый для уничтожения рабочей области;
	<LI>Если в результате проверок обнаруживаются недопустимые входные данные, то следует (в большинстве случаев, в зависимости от задачи) прервать выполнение подпрограммы путем генерации исключения с помощью функции DoError(). В результате вызова этой функции прервется выполнение всех вложенных процедур и произойдет уничтожение всех временных рабочих областей;
	<LI>Имя выходного массива следует (в зависимости от задачи) проверять с помощью функции CheckResAr(). Если задана пустая строка, то функция изменит ее на стандартное имя 'ans'. Если задано недопустимое имя массива, то функция сгенерирует исключение;
	<LI>Если ваша подпрограмма вызывает другую внешнюю функцию, которая должна обработать ваши массивы, то в качестве ссылки на свою рабочую область (первый аргумент функции) вы должны указать переменную <B>SelfWS</B>, которая является типизированным указателем на вашу рабочую область (т.е. ссылка).
	<LI>Вычислительный алгоритм должен быть продуманным. Старайтесь организовать вычисления таким образом, чтобы число инициализаций новых массивов было минимальным. Дело в том, что некоторые функции ядра Matrix проверяют, существует ли выходной массив в данной рабочей области. Если он существует и имеет такие же размеры (или число элементов), как у результирующего массива, то лишней инициализации массива не будет и код выполнится быстрее (в несколько раз быстрее, в зависимости от конкретного случая);
	<LI>Снабжайте программу необходимыми комментариями. Если имеется довольно запутанный вычислительный алгоритм, то приводите соответствующие формулы на математическом языке;
	<LI>Старайтесь реже обращаться к отдельным элементам массивов с помощью свойств Elem[], ElemI[]. Первое свойство самое простое в использовании, т.к. обращение к массиву происходит непосредственно по его имени. Однако приходится каждый раз искать индекс массива по его имени, а это выполняется довольно долго. Свойство ElemI[] использовать сложнее, т.к. вместо имени массива приходится указывать его индекс, но работает этот способ значительно быстрее. Самый быстрый способ доступа к элементам массива - использование свойства ElemFast[]. Однако, использовать это свойство еще сложнее - необходимо указывать адрес массива и число столбцов. Для получения максимально быстрого кода желательно использовать свойство ElemFast[].
	<LI>Если вы используете индексы массивов (например, для использования в свойстве ElemI[], то используйте названия переменных наподобие следующих: aIdx, bIdx, cIdx и т.д., где первая буква соответствует символьному названию соответствующего массива. Например, если у вас есть массив A, то индекс массива должен называться aIdx. Самое главное, чтобы было окончание Idx, указывающее на то, что переменная является индексом.
	<LI>Старайтесь не использовать свернутые выражения, как показано в предыдущем примере. При сворачивании выражений код получается более компактным, но становится абсолютно нечитабельным. Кроме того, при сворачивании выражений могут появиться ошибки, связанные с неправильным порядком вычислений.
</UL>

<P>Рассмотрим правила программирования внешних функций без выделенной рабочей области. Будем использовать тот же пример (D=(A+B)*C). Ниже представлен листинг процедуры:<BR></I>

<pre>
<b>procedure</b> ExternalFunc1(Ws: TWorkspace; A, B, C, D: <b>string</b>);
<b>var</b>
  Tmp: <b>string</b>;
<b>begin</b>
  <b>with</b> Ws <b>do</b> <b>begin</b>
    <i style="color: navy;">// Генерируем исключение при отсутствии одного из массивов</i>
    <b>if</b> (<b>not</b> ArrayExists(A)) <b>or</b> (<b>not</b> ArrayExists(B)) <b>or</b>
      (<b>not</b> ArrayExists(C)) <b>then</b> DoError(matArrayNotFound);
    CheckResAr(D);  <i style="color: navy;">// Проверяем имя выходного массива</i>
    Tmp := GenName(); <i style="color: navy;">// Генерируем имя временного массива</i>
    ElWiseOp(ElWiseOp(<span style="color: navy;">'A'</span>, <span style="color: navy;">'B'</span>, Tmp, <span style="color: navy;">'+'</span>), <span style="color: navy;">'C'</span>, Tmp, <span style="color: navy;">'*'</span>);
    RenameArray(Tmp, D); <i style="color: navy;">// Переименовываем временный массив</i>
  <b>end</b>;
<b>end</b>;
</pre>

<P>Хотя код должен работать немного быстрее, однако приходится выполнять некоторые неудобные дополнительные действия:
<UL>
<LI>объявлять для каждого временного массива свою переменную;<BR>
<LI>не использовать выходной массив в ходе вычислений, а вместо него нужно пользоваться временным массивом;<BR>
<LI>в конце функции или при необходимости генерации исключений необходимо обязательно удалять все временные массивы, однако это получается не всегда. Если ошибка произойдет в первой функции <B>ElWiseOp()</B> (т.е. вложенная функция выполнилась успешно), то произойдет выход из внешней функции, а временные массивы не будут удалены;<BR>
<LI>в конце функции необходимо формировать выходной массив путем переименования соответствующего временного массива с помощью функции <A HREF="../Функции ядра/RenameArray.html"><B>RenameArray()</B></A>.<BR>
</UL>
<P>На самом деле необходимость удаления временных массивов - достаточно существенный недостаток внешних функций без выделенной рабочей области. Дело в том, что в ходе работы функции иногда приходится работать с десятками временных массивов, причем бывают ситуации, когда количество выходных массивов больше одного. Мало того, что для каждого временного массива приходится объявлять строковую переменную и вызывать функцию <B>GenName()</B>, но нужно еще вовремя удалять ненужные временные массивы. Таких проблем в функциях с выделенной рабочей областью не возникает по определению.
Преимущество внешних функций без выделенной рабочей области - более высокая скорость работы, т.к. нет необходимости инициализировать дополнительную рабочую область и выполнять обмен данными. Программист сам должен решить, как нужно реализовать конкретную подпрограмму, однако в большинстве случаев используются временная рабочая область.


</BODY>
</HTML>
